<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">


<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>OSCAL</title>
    <meta name="description" content="">
    <meta name="keywords" content="">

</head>

<body class="en">
    <style>
        div[class^="a-"] {
            width: 50px;
            height: 50px;
            background-color: red;
        }

        #pills-profile .airbuds5Pro_spesc,
        .oscal-specification-table {
            width: 80%;
            max-width: 1200px;
            padding: 100px 0;
            position: relative;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .spesc-img-left {
            width: 40%;
            height: 510px;
        }

        /* 图片未加载时显示 */
        .spesc-img-left img.image-active.on {
            background-image: url('https://www.oscal.hk/img/loading.gif');
            background-size: 20%;
            background-position: center;
            background-repeat: no-repeat;
        }

        @-webkit-keyframes fadeIn {
            0% {
                opacity: 0;
                /*初始状态 透明度为0*/
            }

            100% {
                opacity: 1;
                /*结尾状态 透明度为1*/
            }
        }

        /* 切换颜色后对应产品图片的切换渐变效果 */
        .spesc-img-left img.image-active {
            opacity: 1;
            display: block;
            -webkit-animation-name: fadeIn;
            /*动画名称*/
            -webkit-animation-duration: 1s;
            /*动画持续时间*/
            -webkit-animation-iteration-count: 1;
            /*动画次数*/
        }

        .spesc-img-left img {
            max-width: 400px;
            width: 100%;
            opacity: 0;
            margin: 0 auto;
            display: none;
        }

        .spesc-img-right {
            width: 60%;
        }

        .spesc-img-right .spesc-img-right-ul {
            font-size: 0;
        }

        .spesc-img-right .spesc-img-right-ul .spesc-img-right-ul-li {
            position: relative;
            display: inline-block;
            width: 20%;
            text-align: center;
        }

        .spesc-img-right .spesc-img-right-ul .spesc-img-right-ul-li .spescColor {
            display: inline-block;
            position: relative;
            cursor: pointer;
            width: 49px;
            height: 49px;
            border-radius: 50%;
        }

        .spesc-img-right .spesc-img-right-ul .spesc-img-right-ul-li .spescColorName {
            font-size: 20px;
            margin-top: 10px;
            font-weight: bold;
        }
    </style>
    <div id="AMain" class="main">
        <ul>
            <li>3.1</li>
            <li>3.2</li>
            <li>3.3</li>
        </ul>
        <input type="text" class="ipt" maxlength="255" /><span class="search-btn">Search</span>
        c d d d d d c a
        <!-- 
            遇到的难点：
            1.上传apk并解析里面的参数，据参数和定义的规则自动生成包名，
            2.接口返回数据快慢的覆盖问题，列表、表格数据过多
            3.addEventListener监听事件造成弹窗内submit事件多次执行回调 
            4.input如何处理中文输入--监听compositoinstart,compositionend监听中文输入状态，然后再监听input 回调防抖函数中根据状态再做操作，
            5.element中级联选择器多选时，选中的不按选择顺序排列
            6.在vue中给节点innerHTML插入包含tr、td标签的字符串,显示会丢失部分标签
            8.切换tab标签页echarts缩成一团
            浏览器兼容性：
           1.什么是双向绑定，双向绑定底层原理（就是observer,compile,watch关系），vue2对数组进行双向绑定为何要重写？‘vue2不能监测数组的变化’这句话是否有错，为什么？
           vue2：通过数据劫持结合发布者订阅模式，使用object.definePrototype去动态的监听get,set的同时创建订阅器dep，数据变更发布订阅者，进而触发响应的监听回调事件，vue3:是用ref和reactive去绑定数据，ref是基本数据refImpl，reactive是对象，ref内部是使用reactive去处理的，reactive函数，函数则是通过（target目标,readOnly是否只读，baseHandlers提供handler第二个参数这里面的track和tigger就是依赖收集和修改,collectionHandler这里是set,map,weakset,weakmap的,proxyMap处理proxy和traget的对应关系）用proxy来对数据的响应式代理，refImpl对数据的依赖收集和更新
           2.BFC是啥，触发条件？

           3.原型链，原型，console.log( function instanceof object , object instanceof function , function instanceof function ,object instance object)打印的值，为什么说明原因

           4.常用状态码？浏览器缓存方式有哪些？需要设置哪些参数？同源策略？有10个接口大约每个100ms，chrome需要多少时间加载完（就是同一域名最多加载多少个接口）
           100收到请求处理中，200成功，300重定向，301永久重定向，302临时重定向，304走缓存，400语法错误，401身份权限问题，403资源不可用，404资源未找到，500服务器错误501尚未实施502网关错误，503服务错误，504网关超时，505http协议错误
           5.vue2子组件中‘.sync’和v-model区别,vue3和vue2双向绑定有啥不同，vue3有什么和vue2不同的地方。虚拟DOM节点优异?虚拟dom是如何合并patch的(合并流程)
                组合式API,支持ts,按需加载，新vdom，函数式编程，给新老dom节点首位两端加上标识位，俩两SameVnode对比，有4种情况，旧头新头，旧尾新尾这俩种情况直接patchVnode更新，旧头==新尾则真实dom移动到了旧后，旧尾==新头，则真实dong移动到了旧前，对比完之后进行key值得比较，
                拿key去oldKeyToIdx去旧节点寻找是否存在索引关系，遍历旧节点通过sameVnode判断是否存在相同节点，不存在则新建dom,存在则判断是不是同一节点，不是则新建，是同一节点得话则进行patchVnode更新差异，移动新节点索引，继续循环，会出现俩种情况
                一种是旧子节点数大于新子节点数：旧去除多余节点数
                旧子节点数小于新子节点数：将新的加入到旧右
           6.map和set的区别，filter,every,flat作用，promise是什么，.all和.allsettle区别，.race和.any区别，能否手写promise
           7.js是单还是双进程为什么？进程在内存如何运行（就是哪些任务推到主进程，哪些任务到任务队列）；什么是任务队列，什么是微任务和宏任务，上面的俩个任务的执行顺序，哪些是微任务哪些是宏任务？
           8.高阶函数知道哪些（防抖，节流，柯里化，扁平化数组，树型，深度优先，广度优先，深拷贝能否手写）
           9.this绑定的方法？new做了什么事？script标签中defer和async区别？
            let obj = Object.create(null)
            Object.setPrototype(obj,con.prototype)
            let res = con.apply(obj,args)
            return res instanceof object ? res:obj
           10.画0.5px的线？画三角形？盒模型？css选择器？伪类和伪元素区别？
           11.HTTP浏览器输入URL后发生了什么?页面如何渲染?垃圾回收机制？
            1.补全域名，通过DNS解析出服务器ip地址，通过ip请求建立tcp连接，建立成功后发送http请求，服务器接收后发送html,客户端接收html进行渲染呈现，然后断开tcp连接
           12.选择排序，快速排序，希尔排序，归并排序，插入排序
            display:
            块元素（可改变元素的高宽），行内:，行内块：

            express和koa的区别:
            node子进程：

            node如何处理高并发：node是异步非拥塞单进程语言，1.单进程，少了线程切换的消耗和冲突的风险，缺点也很明显就是无法充分理由多核，pm2,2.事件轮询和libUVn对异步IO的处理，，timer,pending callback,idle,perpare,poll,cehck,close callback
            1.
            node事件轮询6个阶段：
            如何异步处理IO：
            webpack构建过程：根据入口文件逐层抓取依赖文件，然后分析编译转换输出，最后打包，loadering转换文件,plugin全局配置
            项目体积：
            loader转换器、plugins是扩展器：
            Map是，Set是
            filter筛选，every遍历判断每一个是否符合条件，flat扁平化数组
            es6的新特性 
            Promsie
            箭头函数和普通函数的区别：
            new: 
            function newFn(fn) {
            }
            let,var，const
            堆和栈,
            闭包的原理：能够访问定义时的词法作用域
            js事件轮询:
            js类型：基本数据类型(unll,undefind,boolean,string,number,bigInt,symbol)引用数据类型(object,function,array)
            display:
            强缓存：expires,cache-control,协商缓存:etag+if-none-match     last-modified+if-modified-since
            虚拟dom：用js模拟一个树形结构的虚拟dom节点，
            vuediff算法的原理：1.新老dom节点俩段加上标识位，进行对比，旧头等于新尾则真实dom移动到旧前，旧尾等于新头则真实dom移动到旧后，如果都没有则进行key值的比较，首先有个名叫oldKeyToIdx的索引表里面是真实dom的映射关系，如果key寻未到，则新建dom，有找到，则判断是否是同一节点saveVnode,不是的话新建，是则patchvnode更新，遍历完有俩种情况，旧子节点数大于新子节点数去除多余的节点，新子节点数大于旧子节点数旧添加多余的，
            vue双向绑定的原理：baseHandlers, track,tigger,collectionHandlers,proxyMap,存放targer和proxy的索引，通过proxy对数据进行响应式绑定，reflect对数据源的修改与更新
            keep-alive：避免组件重复渲染
            vue如何解析template：1.parse解析tem中的标签，指令，变量生成ast抽象语法树 2.用optimize优化抽象语法树，3.用generator去递归拼接字符串，然后生成rander函数
            如何构建ast流程：
                parsehtml去解析，（start,char,end,commed）
                1.注释commed,去找到第一个'<'，用正则表达式去匹配有几种情况：h5的文件标识，meta,注释，用advance()解析去除后进行开始标签的匹配
                2.开始标签也是正则表达式去匹配，并且遇到开始标签会入栈,之后循环解析属性，
                3.然后解析变量，动态和金泰，动态则根据token去找对应的变量
                4.正则匹配结束标签出栈。
     
        1.不管是前端还是后端，我们程序员我觉得应该是具备一种发现工作上有什么大量重复性工作，就要将功能或者程序简单化来做事，还有就是有对代码的优雅或者完美的追求，我和同事经常开玩笑，说不把这个弄完我睡觉都睡不着，复杂的事情简单化，简单的事情优雅化，目的就是方便我们自己或者同事已达到更高效的工作方式，高效才是我们程序员要一直追寻的目标方向，但是呐身体才是
        -->
        <input type="text" id="inp" />
        <div
            style="height: 1px;width: 200px;background-color: #000;transform: scaleY(.5);transform-origin: 50% 100%;margin: 50px;">
        </div>
        <div id="show"
            style="box-sizing: content-box;width: 0;height: 0;margin: 100px auto;border-left: 50px solid transparent;border-right: 50px solid transparent;border-top: 50px solid transparent;border-bottom: 50px solid red;">
            <!-- <div style="width: 50px;height: 50px;background-color: red;margin: 50px;overflow:hidden;"></div>
            <div style="width: 50px;height: 50px;background-color: yellow;margin: 50px;display: inline-block;"></div> -->
        </div>
        <div>
            <canvas id="myCanvas" width="500" height="500"></canvas>
            <style>
                #myCanvas {
                    position: fixed;
                }
            </style>
        </div>
        <div id='deep'>
            <div class="parent">
                <div class="child-1">
                    <div class="child-1-1">
                        <div class="child-1-1-1">
                            a
                        </div>
                    </div>
                    <div class="child-1-2">
                        <div class="child-1-2-1">
                            b
                        </div>
                    </div>
                    <div class="child-1-3">c</div>
                </div>
                <div class="child-2">
                    <div class="child-2-1">
                        d
                    </div>
                    <div class="child-2-1">
                        e
                    </div>
                </div>
                <div class="child-3">
                    <div class="child-3-1">
                        f
                    </div>
                </div>
            </div>
        </div>
        <div style="height: 500px;width: 500px;background-color: rgb(255, 255, 255);overflow:scroll;" id="test2">
            <div style="width: 500px;height: 1000px;position: relative;">
                <div id="test1"
                    style="position: absolute;top: 300px;left: 0;width: 500px;height: 10px;background-color: red;">
                </div>
            </div>
        </div>
        <div class="tab-pane fade" id="pills-profile" role="tabpanel" aria-labelledby="pills-profile-tab">
            <div class="airbuds5Pro_spesc">
                <div class="spesc-img-left">
                    <img class="lazyload image-active on"
                        data-src="https://d2kbvjszk9d5ln.cloudfront.net/yshop/upload/pic/c20-20210729101859375.png"
                        alt="c20">
                    <img class="lazyload"
                        data-src="https://s3.eu-west-1.amazonaws.com/promo.blackview.hk/activity/oscal/img/c80.png"
                        alt="c20">
                    <img class="lazyload"
                        data-src="https://s3.eu-west-1.amazonaws.com/promo.blackview.hk/activity/oscal/img/s60.png"
                        alt="c20">
                    <img class="lazyload"
                        data-src="https://s3.eu-west-1.amazonaws.com/promo.blackview.hk/activity/oscal/img/c80.png"
                        alt="c20">
                </div>
                <div class="spesc-img-right">
                    <ul class="spesc-img-right-ul">
                        <li class="spesc-img-right-ul-li spesc-active" num='0'>
                            <div class="spescColor"
                                style="background: linear-gradient(90deg, #646060 16%, #373737 41%, #565656 73%, #363636 99%);">
                            </div>
                            <p class="spescColorName">black</p>
                        </li>
                        <li class="spesc-img-right-ul-li" num='1'>
                            <div class="spescColor"
                                style="background: linear-gradient(90deg, #5692A9 16%, #3C768C 41%, #5F99AF 73%, #468096 99%);">
                            </div>
                            <p class="spescColorName">black</p>
                        </li>
                        <li class="spesc-img-right-ul-li" num='2'>
                            <div class="spescColor"
                                style="background: linear-gradient(90deg, #66C2A0 16%, #56A787 41%, #77CEAF 73%, #56A787 99%);">
                            </div>
                            <p class="spescColorName">black</p>
                        </li>
                        <li class="spesc-img-right-ul-li" num='3'>
                            <div class="spescColor"
                                style="background: linear-gradient(90deg, #94B2F2 16%, #6F8CDA 41%, #93B0F2 73%, #7493E6 99%);">
                            </div>
                            <p class="spescColorName">black</p>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <div class="a-1"></div>
    <div class="a-2"></div>
    <div class="a-3"></div>
</body>
<script src="https://d2kbvjszk9d5ln.cloudfront.net/yshop/upload/other/jquery-3.3.1.min-20201130021002922.js"></script>
<script async
    src="https://d2kbvjszk9d5ln.cloudfront.net/yshop/upload/other/lazysizes.min-20201204070627489.js"></script>

<script>
        // let obj = {
    //     a: 1,
    //     b: {
    //         c: 2
    //     }
    // }
    // const handler = {
    //    
    // }
    // const proxy = new Proxy(obj, handler)
    // proxy.a = 10; 
    // proxy.b.c = 20; 
    // console.log(obj);
    //  0<=元素距离顶部的高度-盒子内滚动高度 <=可视化屏幕大小
    // let obj = {
    //     a: 1,
    //     b: 2,
    //     [Symbol.iterator]: function (val) {
    //     }
    // }
    // var [a, b] = obj
    // console.log(a, b);
    let conArr = [
        { id: 1, name: '部门1', pid: 0 },
        { id: 2, name: '部门2', pid: 1 },
        { id: 3, name: '部门3', pid: 1 },
        { id: 4, name: '部门4', pid: 3 },
        { id: 5, name: '部门5', pid: 4 },
    ]
    // let conArr = [
    // { name: '1', type: 0 },
    // { name: '2', type: 0 },
    // { name: '3', type: 2 },
    // { name: '4', type: 2 },
    // { name: '5', type: 3 },
    // { name: '6', type: 3 },
    // ]
    // [ {type:0,values:[{name:'1',type:0},{name:'2',type:0}]}
    // {type:2,values:[{name:'3',type:2},{name:'4',type:2}]}
    // {type:3,values:[{name:'5',type:3},{name:'6',type:3}]} ]
    function convert(list) {
        let result = []
        let map = list.reduce((p, v) => {
            p[v.id] = v
            return p
        }, {})
        let dom = undefined
        for (const item of list) {
            if (item.pid == 0) {
                result.push(item)
                continue
            }
            if (map[item.pid]) {
                let parent = map[item.pid]
                parent.children = parent.children ?? []
                parent.children.push(item)
            }
        }
        return result
    }
    // console.log(convert(conArr));
    let MathArr = [3, 1, 6, 7, 9, 5, 2, 4, 8, 0, 10]
    // console.log(shallSort(MathArr));
    // 选择排序--选择最小下标
    function selectSort(arr) {
        let min = 0
        let j = 0
        let temp = undefined
        for (let i = 0; i < arr.length; i++) {
            min = i
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[min] > arr[j]) {
                    min = j
                }
            }
            [arr[min], arr[i]] = [arr[i], arr[min]]
        }
        return arr
    }
    // 插入排序--大往右移位
    function insertSort(arr) {
        let temp = undefined
        let i, j = undefined
        for (i = 1; i < arr.length; i++) {
            temp = arr[i]
            j = i - 1
            while (j >= 0 && arr[j] > temp) {
                arr[j + 1] = arr[j]
                --j
            }
            arr[j + 1] = temp
        }
        return arr
    }
    // 归并排序--拆分合并
    function mergeSort(arr) {
        if (arr.length < 2) {
            return arr
        }
        let middle = Math.floor(arr.length / 2)
        let left = arr.slice(0, middle)
        let right = arr.slice(middle)

        return merge(mergeSort(left), mergeSort(right))
    }
    function merge(left, right) {
        let result = []

        while (left.length && right.length) {
            if (left[0] > right[0]) {
                result.push(right.shift())
            } else {
                result.push(left.shift())
            }
        }
        while (left.length) {
            result.push(left.shift())
        }
        while (right.length) {
            result.push(right.shift())
        }
        return result
    }

    // 快速排序--找到基准值pivot
    function quickSort(arr) {
        if (arr.length < 2) {
            return arr
        }
        let pivot = arr.splice(Math.floor(arr.length / 2), 1)[0]
        let left = []
        let right = []

        arr.forEach(p => {
            if (p > pivot) {
                right.push(p)
            } else {
                left.push(p)
            }
        });

        return quickSort(left).concat([pivot], quickSort(right))
    }
    // 希尔排序--在插入的基础上增加最小增量gap
    function shellSort(arr) {
        let temp = undefined
        let i, j = undefined
        let gap = Math.floor(arr.length / 2)
        for (; gap > 0; gap = Math.floor(gap / 2)) {
            for (i = gap; i < arr.length; i++) {
                temp = arr[i]
                j = i - gap
                while (j >= 0 && arr[j] > temp) {
                    arr[j + gap] = arr[j]
                    j = j - gap
                }
                arr[j + gap] = temp
            }
        }
        return arr
    }

    const allRequest = [
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=1",
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=2",
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=3",
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=4",
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=5",
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=6",
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=7",
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=8",
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=9",
        "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs?index=10",
    ];
    function sendRequest(urls, max, callbackFunc) {
        let total = urls.length
        let result = []
        let queue = []
        let current = 0
        let done = 0

        init()

        function init() {
            urls.forEach((url, key) => {
                send(url, key)
            })
        }
        async function send(url, key) {
            if (current >= max) {
                await new Promise((resolve) => queue.push(resolve))
            }
            request(url, key)
        }

        async function request(url, key) {
            current++
            try {
                let res = await fetch(url)
                result[key] = res
            } catch (error) {
                result[key] = error
            } finally {
                current--
                done++

                if (done === total) {
                    callbackFunc(result)
                }
                if (queue.length) {
                    queue.shift()()
                }
            }
        }
    }
    // sendRequest(allRequest, 2, (res) => { console.log(res); })

    // a==1&&a==2,a===1&&a===2
    let val = 0
    // let a = {
    //     val: 1
    // }
    // a.toString = function () {
    //     return this.val++
    // }
    // Object.defineProperty(window, 'a', {
    //     get: function () {
    //         return ++val
    //     }
    // })
    // console.log(a === 1 && a === 2);

    // 路由钩子函数:全局导航：beforeEach beforeResolve afterEach , 单独路由独享:beforeEnter,组件内导航钩子：beforeRouteEnter beforeRouteUpdate beforeRouteLeave
    // 生命周期vue2：
    // 生命周期vue3: 
    // vuex状态管理器:
    // 虚拟dom，
    // 常见的内存泄漏
    function myNew(con, ...args) {

    }
    // object.defineProperty缺点：
    // proxy:
    // HTTP浏览器输入URL后发生了什么:
    // VUE3.0抛弃Object.defineProperty改用ES6的Proxy的理解：
    // 前端性能优化 1.分页，防抖，取消重复请求，switch代替多个if-elseif,懒加载，http缓存，gzip，
    // html--语义化的标签，
    // Object.defineProperty()
    // 如果你现在在自己的开发分支 开发一半 线上有个紧急的bug 需要紧急修改并上线。你怎么办
    class myPromise {
        constructor(exe) {
            this.value = undefined
            this.status = 'pending'
            this.successQueue = []
            this.failureQueue = []

            const resolve = (val) => {
                if (this.status === 'pending') {
                    this.status = 'fulfilled'
                    this.value = val
                    let timer = setTimeout(() => {
                        clearTimeout(timer)
                        this.successQueue.forEach(item => {
                            item(this.value)
                        })
                    }, 0);

                }
            }
            const reject = (val) => {
                if (this.status === 'pending') {
                    this.status = 'rejected'
                    this.value = val
                    let timer = setTimeout(() => {
                        clearTimeout(timer)
                        this.failureQueue.forEach(item => {
                            item(this.value)
                        })
                    }, 0);

                }
            }

            try {
                exe(resolve, reject)
            } catch (error) {
                reject(error)
            }
        }
        then(successFn, failFn) {
            typeof successFn !== "function" ? successFn = res => res : null
            return new myPromise((resolve, reject) => {
                this.successQueue.push(() => {
                    let result = successFn(this.value)
                    result instanceof myPromise ? result.then(resolve, reject) : resolve(result)
                })

                typeof failFn !== "function" ? failFn = res => reject(res) : null
                this.failureQueue.push(() => {
                    let result = failFn(this.value)
                    result instanceof myPromise ? result.then(resolve, reject) : resolve(result)
                })
            })
        }
        catch(fn) {
            return this.then(null, fn)
        }
    }
    let a1 = new myPromise((res, rej) => {
        console.log(1);
        rej(2)
    })
    a1.then((v) => {
        console.log(3);
    }).catch(v => {
        console.log(4);
    })
    Promise.myAll = promises => {//全部成功才成功
        return new Promise((resolve, reject) => {
            let result = []
            let current = 0
            let len = promises.length
            if (len == 0) {
                resolve([])
            }
            promises.forEach((p, v) => {
                Promise.resolve(p).then(res => {
                    result[key] = res
                    current++

                    if (current == len) {
                        resolve(result)
                    }
                })
            })
        })
    }
    Promise.myRace = promises => {//那个快返回那个，后面的失败也不管
        return new Promise((resolve, reject) => {
            promises.forEach(p => {
                Promise.resolve(p).then(resolve).catch(reject)
            })
        })
    }
    Promise.prototype.myFinally = function (fn) {

    }
    Promise.allSettled = promises => {//成功和失败都有返回结果状态

    }
    Promise.myAny = promises => {//全部失败才失败，否则返回

    }
    function deepClone(obj) {

    }
    // let data1 = {
    //     a: [1, 2, 3],
    //     b: null,
    //     c: {
    //         d: 1
    //     }
    // }
    // let data2 = deepClone(data1)
    // data2.a = [4, 5]
    // console.log(data1, data2);
    // console.log(myInstanceof({}, Object));
    function myInstanceof(obj, func) {

    }
    function throttle(fn, args) {

    }
    function debounce(fn, args) {

    }

    const myFlat = (arr) => {

    }
    // let arrFlat = [[1, 4], [2, 3, [5, 6]]]
    // console.log(myFlat(arrFlat));
    function currying(func) {
        let result = []

        const fun = function (...rest) {
            if (rest.length) {
                result.push(...rest)
                return fun
            } else {
                return func(...result)
            }
        }
        return fun
    }
    let add = function (...args) {
        return args.reduce((a, b) => a + b)
    };
    let sum = currying(add)
    // sum(1)(2, 3)
    // sum(4, 5)(6)(7)
    // console.log(sum());
    // console.log(addFn(1, 2, 3)(7, 3) + '');
    function addFn(...m) {
        let args = [...m]

        function rest(...n) {
            args.push(...n)
            return rest
        }
        rest.toString = function () {
            return args.reduce((a, b) => a + b)
        }
        return rest
    }

    function sleep(time) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(2)
            }, time);
        })
    }
    async function run() {
        console.log(1);
        await sleep(5000).then(res => console.log(res))
        console.log(3);
    }
    // run()
    let deepTree = {
        id: '1-1',
        title: '节点1-1',
        children: [
            {
                id: '2',
                title: '节点2',
                children: [
                    {
                        id: '2-1',
                        title: '节点2-1',
                        children: [
                            {
                                id: '2-1-1',
                                title: '节点2-1-1',
                            }
                        ]
                    },
                    {
                        id: '2-2',
                        title: '节点2-1'
                    }
                ]
            },
            {
                id: '1-2',
                title: '节点1-2'
            }
        ]
    }
    let widthTree = [
        {
            id: '1-1',
            title: '节点1-1',
        },
        {
            id: '1-2',
            title: '节点1-2',
            children: [
                {
                    id: '2',
                    title: '节点2',
                    children: [
                        {
                            id: '2-1',
                            title: '节点2-1',
                            children: [
                                {
                                    id: '2-1-1',
                                    title: '节点2-1-1',
                                }
                            ]
                        },
                        {
                            id: '2-2',
                            title: '节点2-1'
                        }
                    ]
                },
            ]

        }
    ]
    let deepTraversal = node => {

    }
    let widthTraversal = (tree) => {

    }
    // console.log(widthTraversal(widthTree));

</script>


</html>